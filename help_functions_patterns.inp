###Help function 

function series and(const list L)
    series out = 1
    loop i=1..nelem(L)
        out = out && L[i]
    endloop
    return out
end function


function series lag(int t, const series s)
    return lags(t, s)[t]
end function

function series mean_price(const bundle d)
    return (d.open + d.close) / 2
end function

function series set_body_len(const bundle d)
    return abs(d.open - d.close)
end function

function series body_len(const bundle d)
    return d.body_len
end function

function series body_top(const bundle d)
    series higher = d.open > d.close
    series bt = (higher * d.open) + (!higher * d.close)
    return bt
end function

function series body_bottom(const bundle d)
    series lower_b = d.open < d.close
    series bt = (lower_b * d.open) + (!lower_b * d.close)
    return bt
end function

function series top_shadow_len(const bundle d)
    return (d.high - body_top(d))
end function

function series bottom_shadow_len(const bundle d)
    return (body_bottom(d) - d.low)
end function

function series is_white(const bundle d)
    return d.open < d.close
end function

function series is_body_long(const bundle d)
    return d.body_len > d.body_len_qIII
end function

function series is_body_short(const bundle d)
    return d.body_len < d.body_len_qI
end function

function series is_bottom_shadow_long(const bundle d)
    return d.bottom_shadow_len_percent > d.bottom_shadow_len_qIII
end function

function series is_bottom_shadow_short(const bundle d)
    return d.bottom_shadow_len_percent < d.bottom_shadow_len_qI
end function

function series is_top_shadow_long(const bundle d)
    return d.top_shadow_len_percent > d.top_shadow_len_qIII
end function

function series is_top_shadow_short(const bundle d)
    return d.top_shadow_len_percent < d.top_shadow_len_qI
end function

function series is_doji(const bundle d)
    return d.open == d.close
end function

function series find_trend(const series s)
    series s_lagged = lag(1, s)
    series trend = sgn(s - s_lagged)
    return trend
end function

function series trend(const bundle d, scalar interval)
    series x = time
    series y = d.close
    series loess_approx = loess(y, x, 2, interval/$nobs)
    trend_f = find_trend(loess_approx)
    return trend_f
end function 

function void init(bundle *self, const list L)
    
    if sum(!ok(L)) > 0
        print "WARNING: NA in list"
        return 
    endif

    if !exists(self)
        self = null
    endif

    bundle default = null
    default.trend_range = 15
    default.quartile_range = 260

    self = self + default

    series self.open = L[1]
    series self.close = L[2]
    series self.high = L[3]
    series self.low = L[4]
    series self.time = time

    series self.body_len = set_body_len(self)

    self.top_shadow_len_percent = top_shadow_len(self) / (self.body_len + 1)
    self.bottom_shadow_len_percent = bottom_shadow_len(self) / (self.body_len + 1)

    series self.body_len_qI = set_quantile(self.body_len, self.quartile_range, 0.25)
    series self.body_len_qIII = set_quantile(self.body_len, self.quartile_range, 0.75)
    series self.top_shadow_len_qI = set_quantile(self.top_shadow_len_percent, self.quartile_range, 0.25)
    series self.top_shadow_len_qIII = set_quantile(self.top_shadow_len_percent, self.quartile_range, 0.75)
    series self.bottom_shadow_len_qI = set_quantile(self.bottom_shadow_len_percent, self.quartile_range, 0.25)
    series self.bottom_shadow_len_qIII = set_quantile(self.bottom_shadow_len_percent, self.quartile_range, 0.75)

    series self.trend = trend(self, self.trend_range)
end function

function matrix set_quantile_old(const series s, scalar step, scalar quantile)
    matrix M = zeros($nobs,1)
    M[1:step] = quantile({s}[1: step], quantile)
    loop i = (step + 1 )..$nobs
        catch M[i] = quantile({s}[i - step: i], quantile)
        err = $error
        errString = sprintf("%d %d %d %d - %d",i,$nobs,step, rows({s}), sum(!ok(s)))
        errorif(err, errString)
    endloop

    return M
end function

function series set_quantile(const series s, scalar step, scalar quantile)
    set skip_missing off
    L = lags(step, s)
    L = s || L
    M = {L}
    M = M'
    series ret_s = vec(quantile(M, quantile))
    scalar first = ret_s[step +1]
    ret_s = ok(ret_s) ? ret_s : first

    return ret_s
end function

function void print_list(list L)
    loop i = 1..nelem(L)
        print sum(L[i])
    endloop
end function


